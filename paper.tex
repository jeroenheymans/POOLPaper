\documentclass[10pt,a4paper,twocolumn]{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
\definecolor{codebg}{rgb}{0.9,0.9,0.9}
\usepackage{listings}
\lstset{language=C++,
backgroundcolor=\color{codebg},
numbers=left,
xleftmargin=9pt,
framexleftmargin=9pt,
basicstyle=\scriptsize,
numberstyle=\scriptsize\color{gray},
breaklines=true,
numbersep=1pt,
tabsize=2}
\author{Jeroen Heymans}
\title{Comparison of two object-oriented languages: C++ and Ruby}
\begin{document}
\maketitle

\section{Introduction}

\subsection{Foreword}
This paper is written for the master course Principles of Object Oriented Languages on the VUB. It contains a comparison between two languages that contain object-oriented features. 

\subsection{The compared languages}
The choice for this paper was C++, a well-known static typed language with good object oriented features, and Ruby, a dynamic typed language that was designed to be as object-oriented as possible.

\subsubsection{C++}
Originally called "C with classes", C++ is a multi-paradigm language based on the popular language C. C++ doesn't require you to write all code in an object-oriented fashion, it is also possible to write all your code in functions.

\subsubsection{Ruby}
The creator of Ruby, Ykihiro Matsumoto, looked at other languages to find an ideal syntax. He watned a scripting language that was more powerful than Perl and more object-oriented than Python. In Ruby, everything is an object. It was influenced by Smalltalk, every type was given methods instance variables.

\subsection{What follows next}
We will compare several important features that belong to object-oriented languages like inheritance, polymorphism, access control and many more.

\section{Comparisons}

\subsection{Classes}
In object-oriented programming, a class is a blueprint that is used to construct objects which we call object instances. We compare the several types of classes that can be made.

\subsubsection{Abstract classes}
An abstract class is a class that can not be instantiated for it is either labelled as abstract or it specifies abstract methods. The general idea of abstract classes is that the class must be extended. In C++, an abstract class is a class having at least one pure virtual function. For example, this is an abstract class in C++:
\begin{lstlisting}
class A {
	public:
		virtual void f() = 0;
};
\end{lstlisting}
If we are trying to compile C++ code where we have instantiated an abstract class, for example like this:
\begin{lstlisting}
int main() {
   A a = new A();
   return 0;
}
\end{lstlisting}
We will receive an output from the compiler that notifies us that this operation is not allowed:
\begin{lstlisting}
g++ a.cpp -o a
a.cpp: In function 'int main()':
a.cpp:10:16: error: cannot allocate an object of abstract type 'A'
a.cpp:3:9: note: because the following virtual functions are pure within 'A':
a.cpp:5:16: note: virtual void A::f()
a.cpp:10:6: error: cannot declare variable 'a' to be of abstract type 'A'
a.cpp:3:9: note: since type 'A' has pure virtual functions
make: *** [a] Error 1
\end{lstlisting}
Abstract classes in Ruby are a different story. Unlike some object-oriented languages, Ruby does not support a keyword like "abstract" or a way like C++ to define an abstract class. Ruby does not provide the necessary tools to create abstract classes. However, the programmer himself can force a class to behave like an abstract class when he makes \textit{:new} private. The extending class must then make \textit{:new} public:
\begin{lstlisting}[language=Ruby]
class A
	private_class_method :new
	def initialize(txt = "Hello!")
		puts txt
	end
end

class B < A
	public_class_method :new
end
\end{lstlisting}

\subsubsection{Concrete classes}

\subsubsection{Inner classes}

\subsubsection{Metaclasses}
In Ruby, a class is also an object. Each class is an instance of the unique metaclass which is built in the language.

\subsubsection{Non-subclassable}

\subsubsection{Partial classes}

\subsubsection{Uninstantiable classes}

\subsection{Inheritance}
In Ruby, a class can only inherit from a single other class. Some other languages like C++ support multiple inheritance, a feature that allows classes to inherit features from multiple classes.
\begin{lstlisting}[language=Ruby]
class Animal
	def breath
		puts "Breathe"
	end
	def speak
		puts "Random noise"
	end
end

class Cat < Animal
	def speak
		puts "Meow"
	end
end
\end{lstlisting}
When using these two classes, one can see that methods will be overriden:
\begin{lstlisting}[language=Ruby]
cat = Cat.new
cat.speak
cat.breath
\end{lstlisting}
This will output:
\begin{lstlisting}
Random noise
Breathe
\end{lstlisting}
Inheritance in C++ is more advanced as it supports multiple inheritance.

Ruby mixin's.

\subsection{Access control}

\subsubsection{Derived classes}
When declaring a derived class in C++, we can provide an access specifier: \textit{public}, \textit{protected} or \textit{private}. For example if we have the base class A, we can create subclass B from A and provide one of the three access specifiers like this:

\begin{lstlisting}
class A { };
class B: public A { };
\end{lstlisting}

The purpose of this access specifier is to alter the access control of the members of the base class via the derived class. The access control is not altered on the original base class. An example:

\begin{lstlisting}
#include <iostream>

class A {
	public:
		int foo;
		A(): foo(0) {};
};

class B : public A { };
 
int main()
{
   B* b = new B();
   b->foo = 3;
   std::cout << "Value foo: " << b->foo << std::endl;
   return 0;
}
\end{lstlisting}

When compiling and excecuting this code, the program will output correctly:
\begin{lstlisting}
Value foo: 3
\end{lstlisting}

If we however change the line access keyword when defining the class B to for example \textit{protected} or \textit{private} (instead of the current \textit{public}), we get a compilation error: 

\begin{lstlisting}
g++ a.cpp -o a
a.cpp: In function 'int main()':
a.cpp:5:7: error: 'int A::foo' is inaccessible
a.cpp:14:7: error: within this context
a.cpp:5:7: error: 'int A::foo' is inaccessible
a.cpp:15:40: error: within this context
make: *** [a] Error 1
\end{lstlisting}

When deriving a class, the following situations can occur:
\begin{itemize}
\item Derive as \textit{public}: public and protected members of the base class remain public and protected members of the derived class.
\item Derive as \textit{protected}: public and protected members of the base class become protected members of the derived class.
\item Derive as \textit{private}: public and protected members of the base class become private members of the derived class.
\end{itemize}
In all cases, private members of the base class remain private, e.g.: not even the derived class can access them unless there is a specific friend declaration within the base class that explicitly grants access to them.

\subsection{The use of super and this/self}

\subsection{Polymorphism}

\subsection{Interfaces}

\subsection{Reflection}

\subsection{Clonable objects}

\subsection{Everything is an object?}

\section{Conclusion}

\section{References}
http://www.ruby-lang.org/en/about/
http://www.cplusplus.com/info/history/
http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=\%2Fcom.ibm.xlcpp8l.doc\%2Flanguage\%2Fref\%2Fcplr142.htm
http://www.klankboomklang.com/2007/10/05/the-metaclass/
http://ruby-extra.rubyforge.org/classes/Object.html
http://www.wikyblog.com/AmanKing/Metaclass_in_Ruby
http://www.klankboomklang.com/2007/10/12/objects-classes-and-jruby-internals/
http://shiningthrough.co.uk/A-comparison-of-Ruby-pass-by-reference-and-C++-pass-by-reference
http://rubylearning.com/satishtalim/ruby_inheritance.html
http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=\%2Fcom.ibm.xlcpp8l.doc\%2Flanguage\%2Fref\%2Fcplr130.htm

\end{document}
